# Table of contents

* [OpenAI 실적 활용 완벽 가이드](README.md)
* [1.0 OpenAI 이해와 준비(기초부터 원리까지)](1.0.md)
* [1.1 OpenAI의 역사와 미션](1.1.md)
* [1.2 생성형 AI(Generative AI)란 무엇인가](1.2.md)
* [1.3 GPT 계열의 발전 과정 (GPT-2 → GPT-3 → GPT-4 → GPT-4o)](1.3.md)
* [1.4 LLM의 작동 원리 요약 (Transformer, Pretraining, Fine-tuning)](1.4.md)
* [2.0 OpenAI 플랫폼 구조 및 API 개요](2.0.md)
* [2.1 API 접근 방식 (REST, SDK 등)](2.1.md)
* [2.2 모델 분류: GPT vs Codex vs Embedding vs DALL·E vs Whisper](2.2.md)
* [2.3 계정, 조직, API 키, 과금 구조 이해](2.3.md)
* [2.4 Rate Limit, 토큰 개념 정리](2.4.md)
* [3.0 개발 환경 구성과 첫 호출](3.0.md)
* [3.1 Python SDK 설치 및 기본 예제](3.1.md)
* [3.2 OpenAI Playground vs 코드 호출](3.2.md)
* [3.3 API Key 관리 및 보안 팁](3.3.md)
* [3.4 에러 처리 및 응답 구조](3.4.md)
* [4.0 Chat Completions API의 구조와 활용](4.0.md)
* [4.1 메시지 역할 구조: system, user, assistant](4.1.md)
* [4.2 temperature, top\_p, max\_tokens, stop 등 주요 파라미터](4.2.md)
* [4.3 대화형 프롬프트 디자인과 흐름 제어](4.3.md)
* [4.4 코드 예제: 요약, 번역, 설명, Q\&A, 문서 작성](4.4.md)
* [5.0 프롬프트 엔지니어링 기법 심화](5.0.md)
* [5.1 Zero-shot / Few-shot / CoT (Chain-of-Thought) 방식](5.1.md)
* [5.2 Structured Output 만들기](5.2.md)
* [5.3 오류 유도 및 방지 예시](5.3.md)
* [5.4 시스템 지시문(System Prompt) 최적화 전략](5.4.md)
* [6.0 Embedding API와 벡터 검색 기반 검색엔진 구축](6.0.md)
* [6.1 Embedding의 개념과 Cosine Similarity](6.1.md)
* [6.2 텍스트 벡터화 실습 (문서, 문장, 문단)](6.2.md)
* [6.3 FAISS, Pinecone, Weaviate 등의 통합](6.3.md)
* [6.4 개인 문서 기반 검색 챗봇 구축 실습](6.4.md)
* [7.0 Function Calling & JSON Mode](7.0.md)
* [7.1 함수 호출(Function Call) 구조 이해](7.1.md)
* [7.2 예제: 계산기, 날씨 API, DB 조회기](7.2.md)
* [7.3 JSON Mode 응답 강제 구조화](7.3.md)
* [7.4 JSON + Embedding 조합 활용](7.4.md)
* [8.0 Vision & 이미지 생성/분석 활용](8.0.md)
* [8.1 GPT-4o Vision 이미지 입력 활용법](8.1.md)
* [8.2 OCR 대체, 이미지 설명, UI 구조 해석](8.2.md)
* [8.3 DALL·E API로 이미지 생성/편집](8.3.md)
* [8.4 실습: 이미지 기반 Q\&A, 썸네일 생성기](8.4.md)
* [9.0 음성 입력과 출력: Whisper & TTS](9.0.md)
* [9.1 Whisper STT: 음성 → 텍스트 변환](9.1.md)
* [9.2 Audio API를 통한 자연스러운 TTS](9.2.md)
* [9.3 실습: 고객 응대 시스템의 음성화](9.3.md)
* [9.4 다국어 자동 응답 구현](9.4.md)
* [10.0 OpenAI 기반 챗봇/에이전트 개발](10.0.md)
* [10.1 Flask, FastAPI 기반 OpenAI 서비스 구축](10.1.md)
* [10.2 대화 상태 관리: 메모리 설계](10.2.md)
* [10.3 다중 기능 챗봇 구성 전략](10.3.md)
* [11.0 Assistants API 실전 사용법](11.0.md)
* [11.1 Thread, Message, ToolCall 구조의 이해](11.1.md)
* [11.2 코드 실행(Code Interpreter) 연동](11.2.md)
* [11.3 파일 업로드, 검색, 함수 조합](11.3.md)
* [11.4 기존 Chat API와의 차이점 비교](11.4.md)
* [12.0 LangChain & LlamaIndex 연동](12.0.md)
* [12.1 LangChain 기본 구조](12.1.md)
* [12.2 Chain, Agent, Memory의 실전 예제](12.2.md)
* [12.3 RAG (Retrieval-Augmented Generation) 구현](12.3.md)
* [12.4 LangChain & LlamaIndex 연동](12.4.md)
* [13.0 프론트엔드 통합 (React, Streamlit, Gradio 등)](13.0.md)
* [13.1 OpenAI API와의 클라이언트 통신](13.1.md)
* [13.2 실시간 챗 UI 만들기](13.2.md)
* [13.3 Streamlit 기반 데모 서비스](13.3.md)
* [13.4 Gradio로 프로토타입 제작](13.4.md)
* [14.0 요금 최적화와 비용 관리](14.0.md)
* [14.1 토큰 절약을 위한 프롬프트 전략](14.1.md)
* [14.2 Embedding 압축과 캐시 활용](14.2.md)
* [14.3 대량 호출 환경에서의 속도/비용 최적화](14.3.md)
* [15.0 보안과 프롬프트 인젝션 방지](15.0.md)
* [15.1 프롬프트 인젝션 공격 사례](15.1.md)
* [15.2 사용자 입력 검증과 제한](15.2.md)
* [15.3 API Key 보호 및 클라이언트-서버 분리 전략](15.3.md)
* [16.0 A/B 테스트와 사용자 피드백 루프](16.0.md)
* [16.1 챗봇 성능 개선을 위한 피드백 구조](16.1.md)
* [16.2 프롬프트 개선 주기와 테스트](16.2.md)
* [16.3 평가 메트릭 설계 (BLEU, ROUGE, human eval 등)](16.3.md)
* [17.0 OpenAI를 활용한 SaaS/서비스 사례 분석](17.0.md)
* [17.1 문서 요약, 이메일 작성기, 회의록 정리기](17.1.md)
* [17.2 고객상담 챗봇, 교육 콘텐츠 생성기](17.2.md)
* [17.3 업무 자동화 에이전트](17.3.md)
* [18.0 엔터프라이즈 적용 전략과 규제 이슈](18.0.md)
* [18.1 프라이버시, 기업 내 API 활용 전략](18.1.md)
* [18.2 프롬프트 로깅 및 기업 보안 가이드](18.2.md)
* [18.3 한국/유럽/미국의 AI 규제 개요](18.3.md)
* [19.0 한글 처리와 다국어 대응 전략](19.0.md)
* [19.1 한국어 자연어 처리의 난점](19.1.md)
* [19.2 번역 vs 직접 입력 기반 처리](19.2.md)
* [19.3 tokenizer 조정 전략 (cl100k\_base 등)](19.3.md)
* [20.0 AI 에이전트와 멀티모달의 미래](20.0.md)
* [20.1 GPT-4o 이후의 전망: Agentic AI](20.1.md)
* [20.2 멀티모달 통합 서비스 설계 방향](20.2.md)
* [20.3 오픈소스 대안 비교 (Claude, Gemini, Mistral, LLaMA)](20.3.md)
* [부록 A. 주요 오픈소스 벡터 DB 비교표](부록_A.md)
* [부록 B. OpenAI SDK for JavaScript, .NET, Node.js](부록_B.md)
* [부록 C. 테스트용 샘플 데이터셋](부록_C.md)
* [부록 D. GPT API와 Azure OpenAI API 비교](부록_D.md)
