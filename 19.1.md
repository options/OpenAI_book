## Chapter 19. 한글 처리와 다국어 대응 전략

### 19.1 한국어 자연어 처리의 난점

한국어는 세계 주요 언어 중에서도 특히 구조적으로 독특한 특징을 갖고 있어 자연어 처리(NLP)에서 다양한 난점을 야기합니다. 영어에 기반하여 설계된 모델이나 토크나이저(tokenizer)를 그대로 적용할 경우, 문맥 해석 오류, 형태소 단위의 왜곡, 번역 품질 저하 등의 다양한 문제가 발생할 수 있습니다. 본 절에서는 한국어 자연어 처리 과정에서 대표적으로 마주치는 문제들을 체계적으로 정리하고, OpenAI API를 활용할 때 특히 유의해야 할 점에 대해 살펴봅니다.



#### ✅ 1. 언어 구조의 차이: 교착어적 특성과 자유로운 어순

한국어는 대표적인 교착어(agglutinative language)로, 단어에 조사, 어미, 접사 등을 덧붙여 의미를 확장하는 구조를 갖고 있습니다. 이는 주어-목적어-서술어(SOV)의 어순을 가지며 영어의 주어-서술어-목적어(SVO)와 본질적으로 다릅니다.

예:

| 영어 | I eat an apple. |
|------|------------------|
| 한국어 | 나는 사과를 먹는다. |

또한 한국어는 어순이 영어보다 훨씬 자유로워, “사과를 나는 먹는다”, “먹는다 나는 사과를”, “나는 먹는다 사과를” 모두 문법적으로 해석은 가능하나, 의미가 미묘하게 달라질 수 있습니다.

→ 이로 인해 LLM(대규모 언어 모델)은 같은 의미를 가진 문장도 전혀 다른 것처럼 학습하거나 처리하는 경우가 많습니다. 문맥 파악이 어려워지고, 의미 대비 토큰 수가 증가하는 문제로 이어집니다.



#### ✅ 2. 띄어쓰기 오류와 비정형 텍스트

한국어는 띄어쓰기가 의미분석에 매우 중요한 역할을 하지만, 실제 텍스트에서는 띄어쓰기 오류가 빈번하게 발생합니다.

예)

- 표준 표현: 나는 밥을 먹었다.
- 실제 입력: 나눈밥을먹었다 / 난 밥을 먹었따

이러한 비정형 텍스트는 LLM에게 혼란을 줄 수 있고, 특히 OpenAI API에서는 잘못된 띄어쓰기가 의도치 않은 의미 왜곡을 유발할 수 있습니다. 한국어 띄어쓰기는 기술적으로 문장 수준의 의미 이해가 없이는 정확히 수복하기 어려운 문제이기 때문에 어려움이 더욱 커집니다.



#### ✅ 3. 형태소의 복잡성과 어절 단위 처리의 한계

한국어는 하나의 단어(어절)가 여러 개의 의미 단위(형태소)로 구성되는 경우가 대부분입니다. 예를 들어,

- "먹었습니다" → [먹][었][습][니다] 로 나뉘며 각각의 형태소가 시제, 존칭 등을 나타냅니다.

OpenAI GPT 모델은 기본적으로 어절이 아닌 subword(부분어, 토큰) 단위 처리를 사용합니다. 영어 위주로 최적화된 BPE(Byte Pair Encoding) 방식의 tokenizer는 한국어의 복잡한 형태소 체계를 효과적으로 다루지 못하고, 하나의 어절을 다수의 토큰으로 분해하는 비효율을 초래합니다.

예:

- cl100k_base tokenizer 기준  
  "먹었습니다" → ['먹', '었', '습니다'] 로 잘게 쪼개지면서 토큰 수가 불필요하게 늘어납니다.

→ 이로 인한 주요 문제는:

- 모델 호출시 token limit 조기 초과
- 비용 증가 (토큰 수 기반 과금)
- 문맥 흐름 단절 및 의도한 출력 실패



#### ✅ 4. 동일어/동의어/조사 변형 처리의 어려움

한국어는 동일한 의미를 다양한 표현으로 나타낼 수 있고, 조사에 따른 변형도 많습니다. 예를 들어 “사과를 먹다”, “사과 먹기”, “사과를 먹었습니다”, “사과를 먹었어요”, “사과 먹었네” 모두 거의 유사한 동작을 지칭합니다.

→ LLM이 이를 일관성 있게 이해하거나 통일성 있는 결과를 도출하는 데 어려움을 느낍니다.

이러한 중의성과 조사 변형에 따른 의미 차이(이/가, 을/를, 은/는)에 대한 인식이 GPT 모델에 명확히 내장돼 있지 않기 때문에 다음과 같은 문제가 발생할 수 있습니다:

- 질의의 표현 방식에 따라 다른 응답을 유도함
- 번역 시 원문과 의역의 경계가 모호해짐
- 요약, 질문 생성 등 downstream 작업의 품질 저하



#### ✅ 5. 문체, 경어체, 방언 등의 다양성

한국어에는 다양한 존댓말 체계가 존재하며, 문서나 대화의 성격에 따라 문체가 크게 달라질 수 있습니다.

예:

- 반말체: “밥 먹었어?”
- 존댓말: “식사하셨습니까?”
- 중간체: “밥 드셨어요?”

OpenAI GPT의 출력에 일관된 문체를 유지시키려면 system prompt 또는 fine-tuned prompt를 통한 정교한 지시가 필요합니다. 그렇지 않으면 다음과 같은 문제가 생길 수 있습니다:

- 챗봇 응답이 반말/높임말/중간말 혼용
- 사용자 기대 수준과 맞지 않는 어투
- 존댓말 명령어 해석 오류

또한 한국어 방언(예: 사투리)이나 구어체(문자체, 줄임말 등)에 대한 처리가 미흡하며, 이러한 변형어는 GPT가 학습한 주류 표준 언어로 제대로 매핑되지 않는 경우가 많습니다.



#### ✅ 6. 한국어 코퍼스 부족 및 학습 편향

GPT 계열 모델은 인터넷 기반의 거대 텍스트 코퍼스를 통해 사전 학습되는데, 영어 대비 한글 데이터의 양은 매우 적은 편입니다.

- 영어: Reddit, Wikipedia, Common Crawl, GitHub 등 다수
- 한국어: 위키피디아, 뉴스, 웹문서 일부에 한정

또한 일부 학습 데이터는 자동 번역을 포함하거나 지역 커뮤니티의 사용 패턴을 온전히 반영하지 못합니다. 결과적으로 다음과 같은 편향이 발생합니다:

- GPT가 한국 사회 맥락/문화에 익숙하지 않음
- 일상 대화체보다는 문어체, 뉴스체 위주 응답
- OpenAI가 의도한 “중립성” 기준도 미국식 시각 기반



#### ✅ 7. 토크나이저에 따른 비효율 및 해결 시도

GPT 모델의 default tokenizer인 cl100k_base는 한국어 최적화를 위해 설계된 것은 아니기에 다음과 같은 문제가 발생합니다:

- 긴 단어 → 다수의 불필요 토큰 분해
- 의미 단위가 아닌 음절 기반 분해
- 동사 활용형에 따른 토큰 누수 심각

예시:

- “자동차보험할인특약”  
  → cl100k_base에서는 너무 많은 토큰 분해가 이뤄져 10개 이상이 되는 경우도 비일비재합니다.

이러한 문제를 해결하기 위해 다음과 같은 접근이 시도됩니다:

- 번역 기반 처리: 한국어 → 영어 변환 후 API 호출 → 결과 역번역
  - 단점: 뉘앙스 손실, 의역 문제
- 사용자 사전(custom vocabulary) 적용 가능한 프레임워크 사용 (예: HuggingFace Transformers + koBERT 등)
- RAG + Embedding 기반 한국어 특화 수동 파이프라인 조합
- Token compression: 자주 쓰이는 한국어 명사/표현을 단일 토큰으로 사전 정의



### 📌 요약 및 실전 시사점

| 문제 영역 | 주요 원인 | 실전 대응 전략 |
|-----------|-----------|----------------|
| 구조적 차이 | SOV 어순, 교착어 | 역할 명시, 문장 단순화 |
| 형태소/띄어쓰기 | 다양한 문장 변형 | 사용자 입력 전처리 강화 |
| 조사/동의어 | 동일 의미 표현 다양 | system prompt로 통일 강조 |
| 문체 다양성 | 경어체, 반말, 문체 혼용 | 문체 일관성 프롬프트 설계 |
| 데이터 부족 | 영어 대비 학습량 부족 | RAG, 번역 후 API 호출 |
| tokenizer 비적합 | cl100k_base 기준 불리 | 토큰 최적화를 고려한 프롬프트 |



### 🧩 결론

한국어는 자연어 처리에서 구조적, 문화적, 기술적 측면 모두에서 난해한 언어로 간주됩니다. OpenAI API를 활용한 서비스 개발에 있어서는 단순히 프롬프트 최적화뿐 아니라 한국어에 대한 깊은 언어학적 이해가 병행되어야 합니다. 특히 토큰화 과정에서 오는 불이익을 줄이고 사용자 만족도를 확보하기 위해서는 사전 전처리, 번역 보조 처리, 적절한 응답 문체 제어 등의 전략이 함께 적용되어야 합니다. 지금까지 설명한 난점을 잘 이해하고 이를 극복하기 위한 방법을 체계적으로 적용한다면, GPT 기반의 한국어 서비스도 충분히 고품질로 구현할 수 있습니다.